# Notes for Reading Code
by yuanmu.lb

* ./autogen.sh to generate the complete code
	(make distclean -- clean the files generated by autogen.sh)

* true or false: 
	- for testing state of some component, true-Yes, false-No
	- for executing some function, true-1-Failed, false-0-Success

* get offset of struct member:
```
(int)&(((struct type *)NULL)->member)
```

* avoid the deadlock of multi-thread and fork
	- prefork/postfork is to solve this problem
	(http://mail-index.netbsd.org/tech-userlevel/2013/01/07/msg007117.html)
```
                           malloc-lock
                                |
            +---- thread-1 ----<1>--------------------    
            +---- thread-2 ---------------------------  +--------+
    main ---+-- main thread ---(a)--<2>---(b)---------  | Parent |
                                     |                  +--------+
    ---------------------------------|----------------------------
                                     +-- child --(c)--  +--------+
                                                        | Child  |
                                                        +--------+
```
**problem:**
parent has multi threads and thread-1 holds the malloc-lock at <1>.
then main thread fork a child process. the child copy content of 
main thread of parent, including the lock held by thread-1.
But child process does not have thread-1. so the lock in child 
process will never be released and child will be hang up.
(fork just copy the content of thread calling it. it not copys
 all the threads of parent process)

**solution:**
main thread get all locks at (a) before fork and release all 
locks at (b) of parent and (c) of child. This is what prefork/postfork
do.

* GDB with jemalloc

jemalloc is compiled default in gcc debug mode.
(configure.ac line 146 : -g3)
(-g means -g2; -g3 means more details)
but original jemalloc is compiled in gcc -O3 in default. this may reorder the 
code, expand the loop, etc that makes you confused at gdb.
and, ./autogen.sh --enable-debug could disable the -O3 option. But it will 
enable some debug options, like opt.junk, etc.
So, I modified the -O3 to -O0 in configure.ac in line 750~760
```
	[prepare jemalloc]
	./autogen.sh
	make
	(if you want to enable debug mode, run './autogen.sh --enable-debug')
	(to clean the files generated by make, run 'make clean')
	[compile gdb test]
	cd gdb-it
	gcc -g3 -o malloc malloc.c
	[run gdb]
	gdb malloc
	(gdb) set environment LD_PRELOAD=../lib/libjemalloc.so
	(gdb) b jemalloc_constructor
	(gdb) r
```

* initialize a struct
{...} could be used to initialize/assign a struct, for example :
	```
		struct person{
			int id;
			char * name;
		};
		struct person me={1, "yuanmu"};
	```

* TSD/TLS : thread specific data / thread local storage

we can use pthread APIs(pthread_key_create,...) to control tsd/tls.
use pthread_key_create to create tsd in one place 
and then every thread will have this tsd in its own space. 
```
                                  +--- thread 1 --- get tsd-A ---
    main thread -- create tsd-A --+-- main thread - get tsd-A ---
                                  +--- thread 2 --- get tsd-A ---
```  
tsd-A is stored in thread own space. so tsd-A in different 
threads has different values. they just has the same name.

* size_class : line 780 of size_classes.h
	- LG_SIZEOF_PTR is the bytes of pointer
 	- size = 1<<lg_grp + ndelta<<lg_delta
    - LG_QUANTUM is Base 2 log of minimum allocation alignment (configure.ac line 1103)
 	- bin:yes means small bin class
 	- lg_delta_loopup != 0 means in loop up table

* commit & decommit
commit and decommit is a state of memory(OS) or chunk(jemalloc).

for OS, os_overcommit maybe 0,1,2. 0 means memory address space could not be larger
than physical memory. 1,2 mean memory address space could be larger than physical 
memory with different limits and different strategies.

when use mmap, protection flags could be PROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONE.
the memory address space with PROT_EXEC/PROT_READ/PROT_WRITE will be accounted 
as commited memory. and memory address with PROT_NONE will not be accounted as 
commited memory.

in jemalloc, PAGES_PROT_COMMIT means PROT_READ|PROT_WRITE, PAGES_PROT_DECOMMIT means
PROT_NONE. when deallocating a chunk, try to munmap it. if failed, try to decommit it.

when decommit a chunk, if os_overcommit is true(1,2), do nothing. because os allows 
memory address space larger than physical memory. if os_overcommit is 0, then use 
mmap with PAGES_PROT_DECOMMIT flag to decommit memory space.

(if decommit failed, use chunk_purge to call madvise to purge the memory.)

and then, call chunk_record to put the address space back into retained trees for
later use.

* node of chunk and huge
node of chunk is in the chunk header, and node of huge is allocated in the his own 
arena.

* chunk and huge
chunk means a chunk block or a huge block with multi chunks.
in most case, arena_chunk means simple chunk, and chunk means chunks and huges

* runs_dirty has dirty runs, and also has dirty chunks(chunk node and huge node)

* extent node has many fields, some for tree linkage, some for list linkage, ...
so one node can put into many data structs, like heap, red-black tree, list, ...
jemalloc uses this method to manage nodes. so it can use list to traversal all
the nodes and use red-black tree to search nodes. it works in high performance




## 遗留问题

* tsd state 的四个状态具体含义和作用

* tsd arenas_tdata_bypass 的作用

* ctl 是干嘛的

* 哪些 在 base 中分配，哪些在 arena 0 中分配，哪些在自己的 arena 中分配

* malloc_mutex_lock, witness 等关于锁的细节

* arena_purge 的 decay 模式具体如何工作

* arenas_tdata 是 一个 arena 一个，还是每个线程都有每个 arena 的 arena_tdata?
如果每个都有，那么arena 对于每个线程是单独计时？？

## 笔记
* 内存释放不是非要按照 chunk 为单位的
arena_purge_to_limit 中对run 的回收会使用 chunk_decommit_default/chunk_purge_wrapper 释放chunk中部分页面，
优先使用 decommit，不行的话，使用 chunk_purge，purge 最后会调用 madvise 来
释放页面，并且在linux平台上，使用 madvise 释放后，会将 run 置为 zero 
如果使用 decommit ，则会将 run 置为 decommit

chunk_purge 其实就是用来释放 run 的
chunk自己的释放其实是通过 chunk_dalloc_wrapper 实现的，该函数最终使用 munmap
来释放chunk，而根据 linux 文档，munmap 释放时，即使要释放的空间有部分已经释放，其会将没释放的继续释放，并正确执行完成。

那么，对于 有部分run释放的 chunk，释放时其dirty pages 怎么算？
其实，有部分 run 释放的 chunk，不会被记录在 dirty chunks中，
而是记录在 achunks 中 (所以，achunks 中记录的不全是正在使用的 chunk，而是被切成 run
 的chunk)
比如，chunk = run 1 of zeroed + run 2 of dirty + run 3 of zeroed，该chunk 就在 achunk
中，虽然该chunk没有被使用，但是内部 run 没有被合并
这样一个 chunk 会在 arena_purge 时， run 2 --> zeroed,然后和 run1、run3 合并，最后
整个chunk被dalloc

对于 arena_purge， X 如果在 runs_dirty 和 chunks_cache 中，那么 X 是dirty chunk，
使用 chunk_dalloc，如果 X 只在 runs_dirty 中，先使用 chunk_purge 将 run 物理页面
清洗掉，状态置为 decommit或者zero，然后和前后run合并，如果可以合并成 chunk，再将
chunk 释放。



