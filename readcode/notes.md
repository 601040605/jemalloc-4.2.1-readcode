# Notes for Reading Code
by yuanmu.lb

* ./autogen.sh to generate the complete code
	(make distclean -- clean the files generated by autogen.sh)

* true or false: 
	- for testing state of some component, true-Yes, false-No
	- for executing some function, true-1-Failed, false-0-Success

* get offset of struct member:
```
(int)&(((struct type *)NULL)->member)
```

* avoid the deadlock of multi-thread and fork
	- prefork/postfork is to solve this problem
	(http://mail-index.netbsd.org/tech-userlevel/2013/01/07/msg007117.html)
```
                           malloc-lock
                                |
            +---- thread-1 ----<1>--------------------    
            +---- thread-2 ---------------------------  +--------+
    main ---+-- main thread ---(a)--<2>---(b)---------  | Parent |
                                     |                  +--------+
    ---------------------------------|----------------------------
                                     +-- child --(c)--  +--------+
                                                        | Child  |
                                                        +--------+
```
**problem:**
parent has multi threads and thread-1 holds the malloc-lock at <1>.
then main thread fork a child process. the child copy content of 
main thread of parent, including the lock held by thread-1.
But child process does not have thread-1. so the lock in child 
process will never be released and child will be hang up.
(fork just copy the content of thread calling it. it not copys
 all the threads of parent process)

**solution:**
main thread get all locks at (a) before fork and release all 
locks at (b) of parent and (c) of child. This is what prefork/postfork
do.

* GDB with jemalloc

jemalloc is compiled default in gcc debug mode.
(configure.ac line 146 : -g3)
(-g means -g2; -g3 means more details)
but original jemalloc is compiled in gcc -O3 in default. this may reorder the 
code, expand the loop, etc that makes you confused at gdb.
and, ./autogen.sh --enable-debug could disable the -O3 option. But it will 
enable some debug options, like opt.junk, etc.
So, I modified the -O3 to -O0 in configure.ac in line 750~760
```
	[prepare jemalloc]
	./autogen.sh
	make
	(if you want to enable debug mode, run './autogen.sh --enable-debug')
	(to clean the files generated by make, run 'make clean')
	[compile gdb test]
	cd gdb-it
	gcc -g3 -o malloc malloc.c
	[run gdb]
	gdb malloc
	(gdb) set environment LD_PRELOAD=../lib/libjemalloc.so
	(gdb) b jemalloc_constructor
	(gdb) r
```

* initialize a struct
{...} could be used to initialize/assign a struct, for example :
	```
		struct person{
			int id;
			char * name;
		};
		struct person me={1, "yuanmu"};
	```

* TSD/TLS : thread specific data / thread local storage

we can use pthread APIs(pthread_key_create,...) to control tsd/tls.
use pthread_key_create to create tsd in one place 
and then every thread will have this tsd in its own space. 
```
                                  +--- thread 1 --- get tsd-A ---
    main thread -- create tsd-A --+-- main thread - get tsd-A ---
                                  +--- thread 2 --- get tsd-A ---
```  
tsd-A is stored in thread own space. so tsd-A in different 
threads has different values. they just has the same name.

* size_class : line 780 of size_classes.h
	- LG_SIZEOF_PTR is the bytes of pointer
 	- size = 1<<lg_grp + ndelta<<lg_delta
    - LG_QUANTUM is Base 2 log of minimum allocation alignment (configure.ac line 1103)
 	- bin:yes means small bin class
 	- lg_delta_loopup != 0 means in loop up table

* commit & decommit
commit and decommit is a state of memory(OS) or chunk(jemalloc).

for OS, os_overcommit maybe 0,1,2. 0 means memory address space could not be larger
than physical memory. 1,2 mean memory address space could be larger than physical 
memory with different limits and different strategies.

when use mmap, protection flags could be PROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONE.
the memory address space with PROT_EXEC/PROT_READ/PROT_WRITE will be accounted 
as commited memory. and memory address with PROT_NONE will not be accounted as 
commited memory.

in jemalloc, PAGES_PROT_COMMIT means PROT_READ|PROT_WRITE, PAGES_PROT_DECOMMIT means
PROT_NONE. when deallocating a chunk, try to munmap it. if failed, try to decommit it.

when decommit a chunk, if os_overcommit is true(1,2), do nothing. because os allows 
memory address space larger than physical memory. if os_overcommit is 0, then use 
mmap with PAGES_PROT_DECOMMIT flag to decommit memory space.

(if decommit failed, use chunk_purge to call madvise to purge the memory.)

and then, call chunk_record to put the address space back into retained trees for
later use.

* node of chunk and huge
node of chunk is in the chunk header, and node of huge is allocated in the his own 
arena.

* chunk and huge
chunk means a chunk block or a huge block with multi chunks.
in most case, arena_chunk means simple chunk, and chunk means chunks and huges

* runs_dirty has dirty runs, and also has dirty chunks(chunk node and huge node)

* extent node has many fields, some for tree linkage, some for list linkage, ...
so one node can put into many data structs, like heap, red-black tree, list, ...
jemalloc uses this method to manage nodes. so it can use list to traversal all
the nodes and use red-black tree to search nodes. it works in high performance




