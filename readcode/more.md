## 附录
### 使用 GDB 跟踪 jemalloc
jemalloc 默认使用 gcc -g3 的 debug 选项(configure.ac 第146行)，但是，默认
的优化选项是 gcc -O3，O3选项会开启很多优化，比如 循环展开、指令重排等等，
使得 GDB 跟踪的时候有些信息不准确。而 ./autogen.sh --enable-debug 可以
关闭 -O3 选项，但是这会开启一些 debug 选项，比如 opt.junk 等。所以，
为了简单，我们将 configure.ac 中的 -O3 改为 -O0 (configure.ac 第750-760行)，
这样使用起来比较方便。而在 gdb-it 目录下我们准备了一个测试程序，用来
GDB 跟踪，该测试程序会调用 malloc/free，所以我们可以跟踪 jemalloc 的流程，
下面是具体的操作：
```
	[1. prepare jemalloc]
	./autogen.sh
	make
	(if you want to enable debug mode, run './autogen.sh --enable-debug')
	(to clean the files generated by make, run 'make clean')
	[2. compile gdb test]
	cd gdb-it
	gcc -g3 -o malloc malloc.c
	[3. run gdb]
	gdb malloc
	(gdb) set environment LD_PRELOAD=../lib/libjemalloc.so
	(gdb) b jemalloc_constructor
	(gdb) r
```
至于后续 GDB 的具体使用，这里不介绍，不了解的可以上网搜索。

### 遗留问题

* tsd state 的四个状态具体含义和作用

* tsd arenas_tdata_bypass 的作用

* ctl 是干嘛的

* 哪些 在 base 中分配，哪些在 arena 0 中分配，哪些在自己的 arena 中分配

* malloc_mutex_lock, witness 等关于锁的细节

* arena_purge 的 decay 模式具体如何工作

* arenas_tdata 是 一个 arena 一个，还是每个线程都有每个 arena 的 arena_tdata?
如果每个都有，那么arena 对于每个线程是单独计时？？


